<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>CSharp_Parameter (C#参数工具)</title>
</head>
<body>
<h1>CSharp_Parameter (C#参数工具)</h1>
<p>用于批量增加或移除参数.</p>

<span style="display:none">
<input type="button" title="Do(执行精简)" value="Do" onclick="doReduce();" />
&nbsp; Mode: <select id="cboMode"">
		<option value="0">Normal</option>
		<option value="1" selected="selected">MethodUppercasePrefix</option>
	</select>
&nbsp;<input type="checkbox" id="chkExclude" name="chkExclude" value="1" />Exclude <input id="txtExclude" type="text" size="20" value="(继承自" />
&nbsp; <input type="button" title="PasteDo(粘贴并执行)" value="PasteDo" onclick="doPasteDo();" />
</span>
<br />
<span title="参数类型来源于源参数列表的第几项?">Parameter type by index</span> <input id="txtTypeIndex" type="text" size="3" value="0" />
&nbsp; <input type="checkbox" id="chkParameterModifier" name="chkParameterModifier" value="1" />Parameter modifier:<input id="txtParameterModifier" type="text" size="3" value="out" />
&nbsp; <input type="button" title="Clear source(清空源文本框)" value="Clear source" onclick="clearSource();" />
<br />
<input type="checkbox" id="chkApplyComment" name="chkApplyComment" value="1" checked />Apply to document comment
<span style="display:none">
	&nbsp; <input type="checkbox" id="chkApplyCommentClass" name="chkApplyCommentClass" value="1" checked />Class filter:<input id="txtApplyCommentClass" type="text" size="20" value="I.*" />
</span>
&nbsp; <input type="checkbox" id="chkApplyCode" name="chkApplyCode" value="1" checked />Apply to body code
<br />
<input type="button" title="Add parameter(增加参数)" value="Add parameter" onclick="doAddParameter();" />
&nbsp; Parameter names <input id="txtNames" type="text" size="24" value="args1, args2" />
&nbsp; <input type="button" title="Paste do - Add parameter(粘贴并执行)" value="Paste do" onclick="doAddParameterPaste();" />
<br />
<input type="button" title="Remove parameter(移除参数)" value="Remove parameter" onclick="doRemoveParameter();" />
&nbsp; Remove index <input id="txtRemoveIndex" type="text" size="3" value="-1" />
&nbsp; (-1表示倒数第1项)
&nbsp; <input type="button" title="Paste do - Remove parameter(粘贴并执行)" value="Paste do" onclick="doRemoveParameterPaste();" />
<br />
<br />
<div>
	<div style="display:inline-block; width:45%">
		<textarea id="txtS" rows="30" style="width: 100%"></textarea>
	</div>
	&nbsp; &nbsp; 
	<div style="display:inline-block; width:45%">
		<textarea id="txtD" rows="30" style="width: 100%"></textarea>
	</div>
</div>

<script type="text/javascript">
const clipboardObj = navigator.clipboard;
var reduceExclude = ""; // TODO: remove.
var m_TypeIndex = 0;
var m_ParameterModifier = "";
var m_ApplyComment = false;
var m_ApplyCommentClass = "";
var m_ApplyCode = false;

/** @class BracketInfo
 * Bracket info (括号信息).
 */
function BracketInfo(config) {
	config = config || {};
	this.start = config.start || 0;
	this.len = config.len || 0;
	this.parameterCount = config.parameterCount || 0;
	this.parameterStarts = config.parameterStarts || [];
	this.parameterLens = config.parameterLens || [];
	this.parameterTexts = config.parameterTexts || [];
}

/** Load config
 */
function loadConfig() {
	try {
		const chkParameterModifier = document.getElementById('chkParameterModifier');
		const chkApplyComment = document.getElementById('chkApplyComment');
		const chkApplyCode = document.getElementById('chkApplyCode');
		m_TypeIndex = parseInt(document.getElementById('txtTypeIndex').value)||0;
		m_ParameterModifier = "";
		if (chkParameterModifier.checked) m_ParameterModifier=document.getElementById('txtParameterModifier').value.trim() || "";
		m_ApplyComment = chkApplyComment.checked;
		m_ApplyCommentClass = "";
		if (m_ApplyComment) m_ApplyCommentClass = document.getElementById('txtApplyCommentClass').value.trim();
		m_ApplyCode = chkApplyCode.checked;
	} catch(ex) {
		console.log("Run loadConfig fail!", ex);
	}
}

function onCheck_MethodUppercasePrefix(s, last, userobj) {
	var rt = false;
	if (s.length>0) {
		// Check need join.
		var s1 = s.trimLeft();
		var ch = s1.charAt(0);
		var p = s1.indexOf("(");
		var isFirst = ('A'<=ch)&&(ch<='Z')&&(p>0);
		if (isFirst) {
			var fname = s1.substring(0, p);
			//var fname1 = fname.replace(/(^s*)|(s*$)/g, "");
			var fname1 = fname.replace(/\s+/g,"");
			if (fname.length !== fname1.length) {
				isFirst = false;
			}
			if (fname.indexOf(",")>=0) {
				isFirst = false;
			}
		}
		rt = !isFirst;
	} else {
		// Check ignore line.
		if (reduceExclude.length>0) {
			if (last.indexOf(reduceExclude)>=0) {
				rt = true;
			}
		}
	}
	return rt;
}

/** Reduce empty line - Ex.
 *
 * @param {String[]}	lines	Source lines.
 * @param {Function}	(optional) onCheck	On check callback. Prototype: `function(s, last, userobj)` . s 非空时用于判断是否应合并为一行, s为空时判断是否忽略该行.
 * @param {String}	(optional) separatorJoin	The separator by join.
 * @param {Object}	(optional) userobj	The userobj.
 * @return {String[]}	Return lines.
 */
function reduceEmptyLineEx(lines, onCheck, separatorJoin, userobj) {
	var rt = [];
	var separatorOnMutil = "; ";
	var last = "";
	var i;
	//console.log(lines);
	separatorJoin = separatorJoin || "";
	for(i=0; i<lines.length; ++i) {
		var s = lines[i];
		//var isEmpty = s.replace(/(^s*)|(s*$)/g, "").length ==0;
		var isEmpty = s.replace(/\s+/g,"").length ==0;
		if (!isEmpty) {
			var needJoin = false;
			if (!!onCheck) needJoin = onCheck(s, last, userobj);
			if (needJoin) {
				var separatorNeed = false;
				if (last.length>0) {
					ch = last.charAt(last.length-1);
					var charEmpty = (" "==ch) || ("\t"==ch);
					separatorNeed = !charEmpty;
				}
				if (separatorNeed) {
					last += separatorOnMutil + s;
				} else {
					last += s;
				}
			} else {
				// append.
				if (last.length>0) {
					var ignoreLine = false;
					if (!!onCheck) ignoreLine = onCheck("", last, userobj);
					if (!ignoreLine) {
						rt.push(last);
					}
				}
				// update.
				last = s;
			}
		}
	}
	// done.
	if (last.length>0) {
		// append.
		var ignoreLine = false;
		if (!!onCheck) ignoreLine = onCheck("", last, userobj);
		if (!ignoreLine) {
			rt.push(last);
		}
	}
	return rt;
}

function reduceEmptyLine(lines, mode) {
	var rt = [];
	var onCheck = null;
	var separatorJoin = "; ";
	var userobj = null;
	if (1==mode) onCheck=onCheck_MethodUppercasePrefix;
	rt = reduceEmptyLineEx(lines, onCheck, separatorJoin, userobj);
	return rt;
}

function doReduce() {
	const cboMode = document.getElementById('cboMode');
	const chkExclude = document.getElementById('chkExclude');
	const txtExclude = document.getElementById('txtExclude');
	const txtS = document.getElementById('txtS');
	const txtD = document.getElementById('txtD');
	var mode = cboMode.selectedIndex;
	reduceExclude = "";
	if (chkExclude.checked) reduceExclude=txtExclude.value;
	var lines = txtS.value.split("\n");
	var lines2 = reduceEmptyLine(lines, mode);
	var dst = lines2.join("\n");
	txtD.value = dst;
}

/** Paste and run.
 *
 * @param {Function}	callback	On check callback. Prototype: `function()` .
 */
function pasteAndRun(callback) {
	const txtS = document.getElementById('txtS');
	//const txtD = document.getElementById('txtD');
	// paste.
	if (!clipboardObj) {
		txtS.value = "";
		txtS.select();
		document.execCommand('paste');
		// do.
		if (!!callback) callback();
	} else {
		clipboardObj.readText().then(function(text){
		  //console.log(text);
		  txtS.value = text;
			// do.
			if (!!callback) callback();
		});
	}
}

function doPasteDo() {
	pasteAndRun(doReduce);
}

/** Clear source textbox.
 */
function clearSource() {
	const txtS = document.getElementById('txtS');
	txtS.value = "";
}

/** do AddParameter.
 */
function doAddParameter() {
	const txtS = document.getElementById('txtS');
	const txtD = document.getElementById('txtD');
	var i;
	try {
		loadConfig();
		var parameterNames = document.getElementById('txtNames').value.trim() || "";
		if (parameterNames.length<=0) {
			throw new Error('`Parameter names` can not be empty!');
		}
		var nameList = [parameterNames];
		if (parameterNames.indexOf(",")>=0) {
			nameList = parameterNames.split(",");
			for(i=0; i<nameList.length; ++i) {
				nameList[i] = ("" + nameList[i]).trim();
			}
		}
		// do.
		var lines = txtS.value.split("\n");
		var lines2 = doAddParameter_Core(lines, nameList);
		var dst = lines2.join("\n");
		txtD.value = dst;
	} catch(ex) {
		console.log("Run AddParameter fail!", ex);
		txtD.value = ex;
	}
}

/** Do AddParameter - Core.
 *
 * @param {String[]}	lines	Source lines.
 * @param {String[]}	nameList	Parameter name list.
 * @return {String[]}	Return destination lines.
 */
function doAddParameter_Core(lines, nameList) {
	var rt = [];
	var nameListCount = nameList.length;
	if (nameListCount<=0) {
		throw new Error("The `nameList.length`("+nameListCount+") must >0 !");
	}
	var i, j;
	for(i=0; i<lines.length; ++i) {
		var line = lines[i];
		var dst = line;
		if (typeof(line)=="string" && (line.length>0)) {
			var src = line;
			var srcTrim;
			var srcStart = 0;
			var srcLength = line.length;
			var isComment = false;
			var indexComment = line.indexOf("///");
			if (indexComment>=0) {
				isComment = true;
				srcStart = indexComment + 3;
				if (m_ApplyComment) {
				}
			} else {
			}
			var n = line.indexOf("//", srcStart);
			if (n>=0) {
				srcLength = n - srcStart;
				src = line.substr(0, n);l
			}
			var temp = line.substr(srcStart, srcLength).trim();
			var needDo = (srcLength>0) && (!temp.startsWith("["));
			if (needDo) {
				var bracketInfo = findBracket(line, srcStart, srcLength);
				console.log("Line["+i+"]: ", bracketInfo);
				if (null!=bracketInfo && bracketInfo.parameterCount>m_TypeIndex) {
					var parameterTextSrc = bracketInfo.parameterTexts[m_TypeIndex];
					var parameterType = "";
					var isCodeBody = false;
					if (!isComment) {
						n = parameterTextSrc.lastIndexOf(" ");
						if (n>=0) {
							parameterType = parameterTextSrc.substring(0, n);
						} else {
							isCodeBody = true;
							needDo = m_ApplyCode;
						}
					}
					if (needDo) {
						var insertText = "";
						for(j=0; j<nameList.length; ++j) {
							var parameterTextDst = parameterTextSrc;
							if (parameterType.length>0) {
								parameterTextDst = parameterType + " " + nameList[j];
							} else if (isCodeBody) {
								parameterTextDst = nameList[j];
							}
							if (m_ParameterModifier.length>0) {
								parameterTextDst = m_ParameterModifier + " " + parameterTextDst;
							}
							insertText += ", " + parameterTextDst;
						}
						n = bracketInfo.start + bracketInfo.len - 1;
						dst = line.substring(0, n) + insertText + line.substring(n);
					}
				}
			}
		}
		// done.
		rt.push(dst);
	}
	return rt;
}

/** Find main bracket.
 *
 * @param {String}	src	Source text.
 * @param {Number}	startIndex	(optional) The start index of source.
 * @param {Number}	len	(optional) The length of source.
 * @return {BracketInfo}	Return bracket info. Return null if not found.
 */
function findBracket(src, startIndex, len) {
	var list = findAllTopBracket(src, startIndex, len);
	if (null==list || (list.length<=0)) return null;
	return list[list.length-1];
}

/** Find all top bracket.
 *
 * @param {String}	src	Source text.
 * @param {Number}	startIndex	(optional) The start index of source.
 * @param {Number}	len	(optional) The length of source.
 * @return {BracketInfo[]}	Return bracket info.
 */
function findAllTopBracket(src, startIndex, len) {
	var rt = [];
	startIndex = startIndex || 0;
	if (src.length<startIndex) return rt;
	if (typeof(len)!="number") len = -1;
	var endIndex = src.length;
	if (len<0) {
		// endIndex = src.length;
	} else if (len<1) {
		return rt;
	} else {
		endIndex = startIndex + len;
		if (endIndex>src.length) endIndex=src.length;
	}
	var expressionBlank = /\s+/g;
	var curBracket = null;
	var bracketDeep = 0;
	var parameterUsed = false;
	var parameterCurUsed = false;
	var parameterCurStart = 0;
	var parameterCurEnd = 0;
	var i;
	for(i=startIndex; i<endIndex; ++i) {
		var ch = src.charAt(i);
		if ("("==ch) {
			++bracketDeep;
			if (1==bracketDeep) {
				curBracket = new BracketInfo();
				curBracket.start = i;
				parameterUsed = false;
				parameterCurUsed = false;
				parameterCurStart = i+1;
				parameterCurEnd = parameterCurStart;
			}
		} else if (")"==ch) {
			--bracketDeep;
			if (0==bracketDeep && (null!=curBracket)) {
				curBracket.len = i - curBracket.start + 1;
				if (parameterUsed) {
					var parameterLen = parameterCurEnd - parameterCurStart;
					curBracket.parameterStarts.push(parameterCurStart);
					curBracket.parameterLens.push(parameterLen);
					curBracket.parameterTexts.push(src.substring(parameterCurStart, parameterCurEnd));
					curBracket.parameterCount++;
				}
				rt.push(curBracket);
				curBracket = null;
			}
		} else if (","==ch) {
			if (bracketDeep>0) {
				parameterUsed = true;
				var parameterLen = parameterCurEnd - parameterCurStart;
				curBracket.parameterStarts.push(parameterCurStart);
				curBracket.parameterLens.push(parameterLen);
				curBracket.parameterTexts.push(src.substring(parameterCurStart, parameterCurEnd));
				curBracket.parameterCount++;
				// Next parameter.
				parameterCurUsed = false;
				parameterCurStart = i+1;
				parameterCurEnd = parameterCurStart;
			}
		} else if (expressionBlank.test(ch)) {
			// Blank char.
			if (bracketDeep>0) {
				if (parameterCurUsed) {
				} else {
				}
			}
		} else {
			// NonBlank char.
			if (bracketDeep>0) {
				parameterUsed = true;
				if(!parameterCurUsed) {
					parameterCurUsed = true;
					parameterCurStart = i;
				}
				parameterCurEnd = i+1;
			}
		}
	}
	return rt;
}

function doAddParameterPaste() {
	pasteAndRun(doAddParameter);
}

/** 初始化. */
function init() {
	// compatibility.
	if (!window.URL) {
		window.URL = window.webkitURL || window.mozURL || window.msURL;
	}
}
init();

</script>
</body>
</html>